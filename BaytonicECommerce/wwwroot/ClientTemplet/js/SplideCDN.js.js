/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/@splidejs/splide@3.1.9/dist/js/splide.cjs.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * Splide.js
 * Version  : 3.1.9
 * License  : MIT
 * Copyright: 2021 Naotoshi Fujita
 */
"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); const PROJECT_CODE = "splide", DATA_ATTRIBUTE = "data-splide", CREATED = 1, MOUNTED = 2, IDLE = 3, MOVING = 4, DESTROYED = 5, STATES = { CREATED: 1, MOUNTED: 2, IDLE: 3, MOVING: 4, DESTROYED: 5 }, DEFAULT_EVENT_PRIORITY = 10, DEFAULT_USER_EVENT_PRIORITY = 20; function empty(t) { t.length = 0 } function isObject(t) { return !isNull(t) && "object" == typeof t } function isArray(t) { return Array.isArray(t) } function isFunction(t) { return "function" == typeof t } function isString(t) { return "string" == typeof t } function isUndefined(t) { return void 0 === t } function isNull(t) { return null === t } function isHTMLElement(t) { return t instanceof HTMLElement } function toArray(t) { return isArray(t) ? t : [t] } function forEach(t, e) { toArray(t).forEach(e) } function includes(t, e) { return t.indexOf(e) > -1 } function push(t, e) { return t.push(...toArray(e)), t } const arrayProto = Array.prototype; function slice(t, e, n) { return arrayProto.slice.call(t, e, n) } function find(t, e) { return slice(t).filter(e)[0] } function toggleClass(t, e, n) { t && forEach(e, (e => { e && t.classList[n ? "add" : "remove"](e) })) } function addClass(t, e) { toggleClass(t, isString(e) ? e.split(" ") : e, !0) } function append(t, e) { forEach(e, t.appendChild.bind(t)) } function before(t, e) { forEach(t, (t => { const n = e.parentNode; n && n.insertBefore(t, e) })) } function matches(t, e) { return (t.msMatchesSelector || t.matches).call(t, e) } function children(t, e) { return t ? slice(t.children).filter((t => matches(t, e))) : [] } function child(t, e) { return e ? children(t, e)[0] : t.firstElementChild } function forOwn(t, e, n) { if (t) { let i = Object.keys(t); i = n ? i.reverse() : i; for (let n = 0; n < i.length; n++) { const s = i[n]; if ("__proto__" !== s && !1 === e(t[s], s)) break } } return t } function assign(t) { return slice(arguments, 1).forEach((e => { forOwn(e, ((n, i) => { t[i] = e[i] })) })), t } function merge(t, e) { return forOwn(e, ((e, n) => { isArray(e) ? t[n] = e.slice() : isObject(e) ? t[n] = merge(isObject(t[n]) ? t[n] : {}, e) : t[n] = e })), t } function removeAttribute(t, e) { t && forEach(e, (e => { t.removeAttribute(e) })) } function setAttribute(t, e, n) { isObject(e) ? forOwn(e, ((e, n) => { setAttribute(t, n, e) })) : isNull(n) ? removeAttribute(t, e) : t.setAttribute(e, String(n)) } function create(t, e, n) { const i = document.createElement(t); return e && (isString(e) ? addClass(i, e) : setAttribute(i, e)), n && append(n, i), i } function style(t, e, n) { if (isUndefined(n)) return getComputedStyle(t)[e]; if (!isNull(n)) { const { style: i } = t; n = `${n}`, i[e] !== n && (i[e] = n) } } function display(t, e) { style(t, "display", e) } function focus(t) { t.setActive && t.setActive() || t.focus({ preventScroll: !0 }) } function getAttribute(t, e) { return t.getAttribute(e) } function hasClass(t, e) { return t && t.classList.contains(e) } function rect(t) { return t.getBoundingClientRect() } function remove(t) { forEach(t, (t => { t && t.parentNode && t.parentNode.removeChild(t) })) } function measure(t, e) { if (isString(e)) { const n = create("div", { style: `width: ${e}; position: absolute;` }, t); e = rect(n).width, remove(n) } return e } function parseHtml(t) { return child((new DOMParser).parseFromString(t, "text/html").body) } function prevent(t, e) { t.preventDefault(), e && (t.stopPropagation(), t.stopImmediatePropagation()) } function query(t, e) { return t && t.querySelector(e) } function queryAll(t, e) { return slice(t.querySelectorAll(e)) } function removeClass(t, e) { toggleClass(t, e, !1) } function unit(t) { return isString(t) ? t : t ? `${t}px` : "" } function assert(t, e = "") { if (!t) throw new Error(`[splide] ${e}`) } function nextTick(t) { setTimeout(t) } const noop = () => { }; function raf(t) { return requestAnimationFrame(t) } const { min: min, max: max, floor: floor, ceil: ceil, abs: abs } = Math; function approximatelyEqual(t, e, n) { return abs(t - e) < n } function between(t, e, n, i) { const s = min(e, n), o = max(e, n); return i ? s < t && t < o : s <= t && t <= o } function clamp(t, e, n) { const i = min(e, n), s = max(e, n); return min(max(i, t), s) } function sign(t) { return +(t > 0) - +(t < 0) } function camelToKebab(t) { return t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase() } function format(t, e) { return forEach(e, (e => { t = t.replace("%s", `${e}`) })), t } function pad(t) { return t < 10 ? `0${t}` : `${t}` } const ids = {}; function uniqueId(t) { return `${t}${pad(ids[t] = (ids[t] || 0) + 1)}` } function EventBus() { let t = {}; function e(e, i) { n(e, ((e, n) => { const s = t[e]; t[e] = s && s.filter((t => t._key ? t._key !== i : i || t._namespace !== n)) })) } function n(t, e) { toArray(t).join(" ").split(" ").forEach((t => { const n = t.split("."); e(n[0], n[1]) })) } return { on: function (e, i, s, o = 10) { n(e, ((e, n) => { t[e] = t[e] || [], push(t[e], { _event: e, _callback: i, _namespace: n, _priority: o, _key: s }).sort(((t, e) => t._priority - e._priority)) })) }, off: e, offBy: function (n) { forOwn(t, ((t, i) => { e(i, n) })) }, emit: function (e) { (t[e] || []).forEach((t => { t._callback.apply(t, slice(arguments, 1)) })) }, destroy: function () { t = {} } } } const EVENT_MOUNTED = "mounted", EVENT_READY = "ready", EVENT_MOVE = "move", EVENT_MOVED = "moved", EVENT_CLICK = "click", EVENT_ACTIVE = "active", EVENT_INACTIVE = "inactive", EVENT_VISIBLE = "visible", EVENT_HIDDEN = "hidden", EVENT_SLIDE_KEYDOWN = "slide:keydown", EVENT_REFRESH = "refresh", EVENT_UPDATED = "updated", EVENT_RESIZE = "resize", EVENT_RESIZED = "resized", EVENT_REPOSITIONED = "repositioned", EVENT_DRAG = "drag", EVENT_DRAGGING = "dragging", EVENT_DRAGGED = "dragged", EVENT_SCROLL = "scroll", EVENT_SCROLLED = "scrolled", EVENT_DESTROY = "destroy", EVENT_ARROWS_MOUNTED = "arrows:mounted", EVENT_ARROWS_UPDATED = "arrows:updated", EVENT_PAGINATION_MOUNTED = "pagination:mounted", EVENT_PAGINATION_UPDATED = "pagination:updated", EVENT_NAVIGATION_MOUNTED = "navigation:mounted", EVENT_AUTOPLAY_PLAY = "autoplay:play", EVENT_AUTOPLAY_PLAYING = "autoplay:playing", EVENT_AUTOPLAY_PAUSE = "autoplay:pause", EVENT_LAZYLOAD_LOADED = "lazyload:loaded"; function EventInterface(t) { const { event: e } = t, n = {}; let i = []; function s(t, e, n) { o(t, e, ((t, e) => { i = i.filter((i => !!(i[0] !== t || i[1] !== e || n && i[2] !== n) || (t.removeEventListener(e, i[2], i[3]), !1))) })) } function o(t, e, n) { forEach(t, (t => { t && e.split(" ").forEach(n.bind(null, t)) })) } function r() { i = i.filter((t => s(t[0], t[1]))), e.offBy(n) } return e.on("destroy", r, n), { on: function (t, i, s) { e.on(t, i, n, s) }, off: function (t) { e.off(t, n) }, emit: e.emit, bind: function (t, e, n, s) { o(t, e, ((t, e) => { i.push([t, e, n, s]), t.addEventListener(e, n, s) })) }, unbind: s, destroy: r } } function RequestInterval(t, e, n, i) { const { now: s } = Date; let o, r, l = 0, a = !0, c = 0; function u() { if (!a) { const r = s() - o; if (r >= t ? (l = 1, o = s()) : l = r / t, n && n(l), 1 === l && (e(), i && ++c >= i)) return d(); raf(u) } } function d() { a = !0 } function f() { cancelAnimationFrame(r), l = 0, r = 0, a = !0 } return { start: function (e) { !e && f(), o = s() - (e ? l * t : 0), a = !1, raf(u) }, rewind: function () { o = s(), l = 0, n && n(l) }, pause: d, cancel: f, isPaused: function () { return a } } } function State(t) { let e = t; return { set: function (t) { e = t }, is: function (t) { return includes(toArray(t), e) } } } function Throttle(t, e) { let n; return function () { n || (n = RequestInterval(e || 0, (() => { t.apply(this, arguments), n = null }), null, 1), n.start()) } } function Options(t, e, n) { const i = Throttle(a); let s, o, r; function l(t) { t && removeEventListener("resize", i) } function a() { const e = find(o, (t => t[1].matches)) || []; e[0] !== r && function (e) { const i = n.breakpoints[e] || s; i.destroy ? (t.options = s, t.destroy("completely" === i.destroy)) : (t.state.is(5) && (l(!0), t.mount()), t.options = i) }(r = e[0]) } return { setup: function () { try { merge(n, JSON.parse(getAttribute(t.root, "data-splide"))) } catch (t) { assert(!1, t.message) } s = merge({}, n); const { breakpoints: e } = n; if (e) { const t = "min" === n.mediaQuery; o = Object.keys(e).sort(((e, n) => t ? +n - +e : +e - +n)).map((e => [e, matchMedia(`(${t ? "min" : "max"}-width:${e}px)`)])), a() } }, mount: function () { o && addEventListener("resize", i) }, destroy: l } } const RTL = "rtl", TTB = "ttb", ORIENTATION_MAP = { marginRight: ["marginBottom", "marginLeft"], autoWidth: ["autoHeight"], fixedWidth: ["fixedHeight"], paddingLeft: ["paddingTop", "paddingRight"], paddingRight: ["paddingBottom", "paddingLeft"], width: ["height"], left: ["top", "right"], right: ["bottom", "left"], x: ["y"], X: ["Y"], Y: ["X"], ArrowLeft: ["ArrowUp", "ArrowRight"], ArrowRight: ["ArrowDown", "ArrowLeft"] }; function Direction(t, e, n) { return { resolve: function (t, e) { const { direction: i } = n; return ORIENTATION_MAP[t][i !== RTL || e ? i === TTB ? 0 : -1 : 1] || t }, orient: function (t) { return t * (n.direction === RTL ? 1 : -1) } } } const CLASS_ROOT = "splide", CLASS_SLIDER = "splide__slider", CLASS_TRACK = "splide__track", CLASS_LIST = "splide__list", CLASS_SLIDE = "splide__slide", CLASS_CLONE = "splide__slide--clone", CLASS_CONTAINER = "splide__slide__container", CLASS_ARROWS = "splide__arrows", CLASS_ARROW = "splide__arrow", CLASS_ARROW_PREV = "splide__arrow--prev", CLASS_ARROW_NEXT = "splide__arrow--next", CLASS_PAGINATION = "splide__pagination", CLASS_PAGINATION_PAGE = "splide__pagination__page", CLASS_PROGRESS = "splide__progress", CLASS_PROGRESS_BAR = "splide__progress__bar", CLASS_AUTOPLAY = "splide__autoplay", CLASS_PLAY = "splide__play", CLASS_PAUSE = "splide__pause", CLASS_SPINNER = "splide__spinner", CLASS_INITIALIZED = "is-initialized", CLASS_ACTIVE = "is-active", CLASS_PREV = "is-prev", CLASS_NEXT = "is-next", CLASS_VISIBLE = "is-visible", CLASS_LOADING = "is-loading", STATUS_CLASSES = [CLASS_ACTIVE, "is-visible", "is-prev", "is-next", "is-loading"], CLASSES = { slide: CLASS_SLIDE, clone: CLASS_CLONE, arrows: CLASS_ARROWS, arrow: CLASS_ARROW, prev: CLASS_ARROW_PREV, next: CLASS_ARROW_NEXT, pagination: CLASS_PAGINATION, page: CLASS_PAGINATION_PAGE, spinner: CLASS_SPINNER }; function Elements(t, e, n) { const { on: i } = EventInterface(t), { root: s } = t, o = {}, r = []; let l, a, c, u; function d() { !function () { a = child(s, ".splide__slider"), c = query(s, ".splide__track"), u = child(c, ".splide__list"), assert(c && u, "A track/list element is missing."), push(r, children(u, `.splide__slide:not(.${CLASS_CLONE})`)); const t = S(".splide__autoplay"), e = S(".splide__arrows"); assign(o, { root: s, slider: a, track: c, list: u, slides: r, arrows: e, autoplay: t, prev: query(e, ".splide__arrow--prev"), next: query(e, ".splide__arrow--next"), bar: query(S(".splide__progress"), ".splide__progress__bar"), play: query(t, ".splide__play"), pause: query(t, ".splide__pause") }) }(), function () { const t = s.id || uniqueId("splide"); s.id = t, c.id = c.id || `${t}-track`, u.id = u.id || `${t}-list` }(), addClass(s, l = h()) } function f() { [s, c, u].forEach((t => { removeAttribute(t, "style") })), empty(r), removeClass(s, l) } function p() { f(), d() } function E() { removeClass(s, l), addClass(s, l = h()) } function S(t) { return child(s, t) || child(a, t) } function h() { return [`${CLASS_ROOT}--${n.type}`, `${CLASS_ROOT}--${n.direction}`, n.drag && `${CLASS_ROOT}--draggable`, n.isNavigation && `${CLASS_ROOT}--nav`, CLASS_ACTIVE] } return assign(o, { setup: d, mount: function () { i("refresh", p, 8), i("updated", E) }, destroy: f }) } const ROLE = "role", ARIA_CONTROLS = "aria-controls", ARIA_CURRENT = "aria-current", ARIA_LABEL = "aria-label", ARIA_HIDDEN = "aria-hidden", TAB_INDEX = "tabindex", DISABLED = "disabled", ARIA_ORIENTATION = "aria-orientation", ALL_ATTRIBUTES = [ROLE, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_HIDDEN, ARIA_ORIENTATION, TAB_INDEX, DISABLED], SLIDE = "slide", LOOP = "loop", FADE = "fade"; function Slide$1(t, e, n, i) { const { on: s, emit: o, bind: r, destroy: l } = EventInterface(t), { Components: a, root: c, options: u } = t, { isNavigation: d, updateOnMove: f } = u, { resolve: p } = a.Direction, E = getAttribute(i, "style"), S = n > -1, h = child(i, `.${CLASS_CONTAINER}`), A = u.focusableNodes && queryAll(i, u.focusableNodes); let _; function g(t, n, i) { _ || (T.call(this), i === e && m.call(this, !0)) } function T() { if (!_) { const { index: n } = t; m.call(this, C()), L.call(this, function () { if (t.is(FADE)) return C(); const e = rect(a.Elements.track), n = rect(i), s = p("left"), o = p("right"); return floor(e[s]) <= ceil(n[s]) && floor(n[o]) <= ceil(e[o]) }()), toggleClass(i, "is-prev", e === n - 1), toggleClass(i, "is-next", e === n + 1) } } function m(t) { t !== hasClass(i, CLASS_ACTIVE) && (toggleClass(i, CLASS_ACTIVE, t), d && setAttribute(i, ARIA_CURRENT, t || null), o(t ? "active" : "inactive", this)) } function L(t) { const e = !t && !C(); setAttribute(i, ARIA_HIDDEN, e || null), setAttribute(i, TAB_INDEX, !e && u.slideFocus ? 0 : null), A && A.forEach((t => { setAttribute(t, TAB_INDEX, e ? -1 : null) })), t !== hasClass(i, "is-visible") && (toggleClass(i, "is-visible", t), o(t ? "visible" : "hidden", this)) } function C() { return t.index === e } return { index: e, slideIndex: n, slide: i, container: h, isClone: S, mount: function () { !function () { S || (i.id = `${c.id}-slide${pad(e + 1)}`); if (d) { const s = S ? n : e, o = format(u.i18n.slideX, s + 1), r = t.splides.map((t => t.root.id)).join(" "); setAttribute(i, ARIA_LABEL, o), setAttribute(i, ARIA_CONTROLS, r), setAttribute(i, ROLE, "menuitem") } }(), r(i, "click keydown", (t => { o("click" === t.type ? "click" : "slide:keydown", this, t) })), s(["refresh", "repositioned", "moved", "scrolled"], T.bind(this)), f && s("move", g.bind(this)) }, destroy: function () { _ = !0, l(), removeClass(i, STATUS_CLASSES), removeAttribute(i, ALL_ATTRIBUTES), setAttribute(i, "style", E) }, style: function (t, e, n) { style(n && h || i, t, e) }, isWithin: function (n, i) { let s = abs(n - e); return t.is(SLIDE) || S || (s = min(s, t.length - s)), s <= i } } } function Slides(t, e, n) { const { on: i, emit: s, bind: o } = EventInterface(t), { slides: r, list: l } = e.Elements, a = []; function c() { r.forEach(((t, e) => { f(t, e, -1) })) } function u() { E((t => { t.destroy() })), empty(a) } function d() { u(), c() } function f(e, n, i) { const s = Slide$1(t, n, i, e); s.mount(), a.push(s) } function p(t) { return t ? S((t => !t.isClone)) : a } function E(t, e) { p(e).forEach(t) } function S(t) { return a.filter(isFunction(t) ? t : e => isString(t) ? matches(e.slide, t) : includes(toArray(t), e.index)) } return { mount: function () { c(), i("refresh", d), i(["mounted", "refresh"], (() => { a.sort(((t, e) => t.index - e.index)) })) }, destroy: u, register: f, get: p, getIn: function (t) { const { Controller: i } = e, s = i.toIndex(t), o = i.hasFocus() ? 1 : n.perPage; return S((t => between(t.index, s, s + o - 1))) }, getAt: function (t) { return S(t)[0] }, add: function (t, e) { forEach(t, (t => { if (isString(t) && (t = parseHtml(t)), isHTMLElement(t)) { const i = r[e]; i ? before(t, i) : append(l, t), addClass(t, n.classes.slide), function (t, e) { const n = queryAll(t, "img"); let { length: i } = n; i ? n.forEach((t => { o(t, "load error", (() => { --i || e() })) })) : e() }(t, s.bind(null, "resize")) } })), s("refresh") }, remove: function (t) { remove(S(t).map((t => t.slide))), s("refresh") }, forEach: E, filter: S, style: function (t, e, n) { E((i => { i.style(t, e, n) })) }, getLength: function (t) { return t ? r.length : a.length }, isEnough: function () { return a.length > n.perPage } } } function Layout(t, e, n) { const { on: i, bind: s, emit: o } = EventInterface(t), { Slides: r } = e, { resolve: l } = e.Direction, { track: a, list: c } = e.Elements, { getAt: u } = r; let d; function f() { d = n.direction === TTB, style(t.root, "maxWidth", unit(n.width)), style(a, l("paddingLeft"), E(!1)), style(a, l("paddingRight"), E(!0)), p() } function p() { style(a, "height", function () { let t = ""; d && (t = S(), assert(t, "height or heightRatio is missing."), t = `calc(${t} - ${E(!1)} - ${E(!0)})`); return t }()), r.style(l("marginRight"), unit(n.gap)), r.style("width", (n.autoWidth ? "" : unit(n.fixedWidth) || (d ? "" : h())) || null), r.style("height", unit(n.fixedHeight) || (d ? n.autoHeight ? "" : h() : S()) || null, !0), o("resized") } function E(t) { const { padding: e } = n, i = l(t ? "right" : "left", !0); return e && unit(e[i] || (isObject(e) ? 0 : e)) || "0px" } function S() { return unit(n.height || rect(c).width * n.heightRatio) } function h() { const t = unit(n.gap); return `calc((100%${t && ` + ${t}`})/${n.perPage || 1}${t && ` - ${t}`})` } function A(t, e) { const n = u(t); if (n) { const t = rect(n.slide)[l("right")], i = rect(c)[l("left")]; return abs(t - i) + (e ? 0 : _()) } return 0 } function _() { const t = u(0); return t && parseFloat(style(t.slide, l("marginRight"))) || 0 } return { mount: function () { f(), s(window, "resize load", Throttle(o.bind(this, "resize"))), i(["updated", "refresh"], f), i("resize", p) }, listSize: function () { return rect(c)[l("width")] }, slideSize: function (t, e) { const n = u(t || 0); return n ? rect(n.slide)[l("width")] + (e ? 0 : _()) : 0 }, sliderSize: function () { return A(t.length - 1, !0) - A(-1, !0) }, totalSize: A, getPadding: function (t) { return parseFloat(style(a, l("padding" + (t ? "Right" : "Left"), !0))) || 0 } } } function Clones(t, e, n) { const { on: i, emit: s } = EventInterface(t), { Elements: o, Slides: r } = e, { resolve: l } = e.Direction, a = []; let c; function u() { (c = E()) && (!function (e) { const i = r.get().slice(), { length: s } = i; if (s) { for (; i.length < e;)push(i, i); push(i.slice(-e), i.slice(0, e)).forEach(((l, c) => { const u = c < e, d = function (e, i) { const s = e.cloneNode(!0); return addClass(s, n.classes.clone), s.id = `${t.root.id}-clone${pad(i + 1)}`, s }(l.slide, c); u ? before(d, i[0].slide) : append(o.list, d), push(a, d), r.register(d, c - e + (u ? 0 : s), l.index) })) } }(c), s("resize")) } function d() { remove(a), empty(a) } function f() { d(), u() } function p() { c < E() && s("refresh") } function E() { let { clones: e } = n; if (t.is(LOOP)) { if (!e) { const i = measure(o.list, n[l("fixedWidth")]); e = (i && ceil(rect(o.track)[l("width")] / i) || n[l("autoWidth")] && t.length || n.perPage) * (n.drag ? (n.flickMaxPages || 1) + 1 : 2) } } else e = 0; return e } return { mount: function () { u(), i("refresh", f), i(["updated", "resize"], p) }, destroy: d } } function Move(t, e, n) { const { on: i, emit: s } = EventInterface(t), { slideSize: o, getPadding: r, totalSize: l, listSize: a, sliderSize: c } = e.Layout, { resolve: u, orient: d } = e.Direction, { list: f, track: p } = e.Elements; let E; function S() { e.Drag.isDragging() || (e.Scroll.cancel(), h(t.index), s("repositioned")) } function h(t) { A(g(t, !0)) } function A(e, n) { t.is(FADE) || (f.style.transform = `translate${u("X")}(${n ? e : function (e) { if (!E && t.is(LOOP)) { const t = d(e - T()), n = C(!1, e) && t < 0, i = C(!0, e) && t > 0; (n || i) && (e = _(e, i)) } return e }(e)}px)`) } function _(t, e) { const n = t - m(e), i = c(); return t -= sign(n) * i * ceil(abs(n) / i) } function g(e, i) { const s = d(l(e - 1) - function (t) { const { focus: e } = n; return "center" === e ? (a() - o(t, !0)) / 2 : +e * o(t) || 0 }(e)); return i ? function (e) { n.trimSpace && t.is(SLIDE) && (e = clamp(e, 0, d(c() - a()))); return e }(s) : s } function T() { const t = u("left"); return rect(f)[t] - rect(p)[t] + d(r(!1)) } function m(t) { return g(t ? e.Controller.getEnd() : 0, !!n.trimSpace) } function L() { return !!E } function C(t, e) { e = isUndefined(e) ? T() : e; const n = !0 !== t && d(e) < d(m(!1)), i = !1 !== t && d(e) > d(m(!0)); return n || i } return { mount: function () { i(["mounted", "resized", "updated", "refresh"], S) }, destroy: function () { removeAttribute(f, "style") }, move: function (i, o, r, l) { if (!L()) { const { set: a } = t.state, c = T(), u = i !== o; E = u || n.waitForTransition, a(4), s("move", o, r, i), e.Transition.start(i, (() => { u && h(o), E = !1, a(3), s("moved", o, r, i), "move" === n.trimSpace && i !== r && c === T() ? e.Controller.go(i > r ? ">" : "<", !1, l) : l && l() })) } }, jump: h, translate: A, shift: _, cancel: function () { E = !1, A(T()), e.Transition.cancel() }, toIndex: function (t) { const n = e.Slides.get(); let i = 0, s = 1 / 0; for (let e = 0; e < n.length; e++) { const o = n[e].index, r = abs(g(o, !0) - t); if (!(r <= s)) break; s = r, i = o } return i }, toPosition: g, getPosition: T, getLimit: m, isBusy: L, exceededLimit: C } } function Controller(t, e, n) { const { on: i } = EventInterface(t), { Move: s } = e, { getPosition: o, getLimit: r } = s, { isEnough: l, getLength: a } = e.Slides, c = t.is(LOOP), u = t.is(SLIDE); let d, f, p, E = n.start || 0, S = E; function h() { d = a(!0), f = n.perMove, p = n.perPage, E = clamp(E, 0, d - 1) } function A(t, n, i, o, r) { const l = n ? t : I(t); e.Scroll.scroll(n || i ? s.toPosition(l, !0) : t, o, (() => { O(s.toIndex(s.getPosition())), r && r() })) } function _(t) { return T(!1, t) } function g(t) { return T(!0, t) } function T(t, e) { const n = f || (N() ? 1 : p), i = m(E + n * (t ? -1 : 1), E); return -1 === i && u && !approximatelyEqual(o(), r(!t), 1) ? t ? 0 : L() : e ? i : C(i) } function m(t, e, i) { if (l()) { const s = L(); t < 0 || t > s ? t = between(0, t, e, !0) || between(s, e, t, !0) ? R(y(t)) : c ? f ? t : t < 0 ? -(d % p || p) : d : n.rewind ? t < 0 ? s : 0 : -1 : c || i || t === e || (t = f ? t : R(y(e) + (t < e ? -1 : 1))) } else t = -1; return t } function L() { let t = d - p; return (N() || c && f) && (t = d - 1), max(t, 0) } function C(t) { return c ? l() ? t % d + (t < 0 ? d : 0) : -1 : t } function R(t) { return clamp(N() ? t : p * t, 0, L()) } function y(t) { return N() || (t = between(t, d - p, d - 1) ? d - 1 : t, t = floor(t / p)), t } function I(t) { const e = s.toIndex(t); return u ? clamp(e, 0, L()) : e } function O(t) { t !== E && (S = E, E = t) } function N() { return !isUndefined(n.focus) || n.isNavigation } return { mount: function () { h(), i(["updated", "refresh"], h, 9) }, go: function (t, e, i) { const o = function (t) { let e = E; if (isString(t)) { const [, n, i] = t.match(/([+\-<>])(\d+)?/) || []; "+" === n || "-" === n ? e = m(E + +`${n}${+i || 1}`, E, !0) : ">" === n ? e = i ? R(+i) : _(!0) : "<" === n && (e = g(!0)) } else e = c ? clamp(t, -p, d + p - 1) : clamp(t, 0, L()); return e }(t); if (n.useScroll) A(o, !0, !0, n.speed, i); else { const t = C(o); t > -1 && !s.isBusy() && (e || t !== E) && (O(t), s.move(o, t, S, i)) } }, scroll: A, getNext: _, getPrev: g, getEnd: L, setIndex: O, getIndex: function (t) { return t ? S : E }, toIndex: R, toPage: y, toDest: I, hasFocus: N } } const XML_NAME_SPACE = "http://www.w3.org/2000/svg", PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z", SIZE = 40; function Arrows(t, e, n) { const { on: i, bind: s, emit: o } = EventInterface(t), { classes: r, i18n: l } = n, { Elements: a, Controller: c } = e; let u, d = a.arrows, f = a.prev, p = a.next; const E = {}; function S() { if (n.arrows && (f && p || (d = create("div", r.arrows), f = h(!0), p = h(!1), u = !0, append(d, [f, p]), before(d, child("slider" === n.arrows && a.slider || t.root)))), f && p) if (E.prev) display(d, !1 === n.arrows ? "none" : ""); else { const { id: t } = a.track; setAttribute(f, ARIA_CONTROLS, t), setAttribute(p, ARIA_CONTROLS, t), E.prev = f, E.next = p, function () { const { go: t } = c; i(["mounted", "moved", "updated", "refresh", "scrolled"], A), s(p, "click", (() => { t(">", !0) })), s(f, "click", (() => { t("<", !0) })) }(), o("arrows:mounted", f, p) } } function h(t) { return parseHtml(`<button class="${r.arrow} ${t ? r.prev : r.next}" type="button"><svg xmlns="${XML_NAME_SPACE}" viewBox="0 0 40 40" width="40" height="40"><path d="${n.arrowPath || PATH}" />`) } function A() { const e = t.index, n = c.getPrev(), i = c.getNext(), s = n > -1 && e < n ? l.last : l.prev, r = i > -1 && e > i ? l.first : l.next; f.disabled = n < 0, p.disabled = i < 0, setAttribute(f, ARIA_LABEL, s), setAttribute(p, ARIA_LABEL, r), o("arrows:updated", f, p, n, i) } return { arrows: E, mount: function () { S(), i("updated", S) }, destroy: function () { u ? remove(d) : (removeAttribute(f, ALL_ATTRIBUTES), removeAttribute(p, ALL_ATTRIBUTES)) } } } function Autoplay(t, e, n) { const { on: i, bind: s, emit: o } = EventInterface(t), { Elements: r } = e, l = RequestInterval(n.interval, t.go.bind(t, ">"), (function (t) { const { bar: e } = r; e && style(e, "width", 100 * t + "%"); o("autoplay:playing", t) })), { isPaused: a } = l; let c, u, d; function f(t) { const e = t ? "pause" : "play", i = r[e]; i && (setAttribute(i, ARIA_CONTROLS, r.track.id), setAttribute(i, ARIA_LABEL, n.i18n[e]), s(i, "click", t ? E : p)) } function p() { a() && e.Slides.isEnough() && (l.start(!n.resetProgress), u = c = d = !1, o("autoplay:play")) } function E(t = !0) { a() || (l.pause(), o("autoplay:pause")), d = t } function S() { d || (c || u ? E(!1) : p()) } return { mount: function () { const { autoplay: t } = n; t && (f(!0), f(!1), function () { const { root: t } = r; n.pauseOnHover && s(t, "mouseenter mouseleave", (t => { c = "mouseenter" === t.type, S() })); n.pauseOnFocus && s(t, "focusin focusout", (t => { u = "focusin" === t.type, S() })); i(["move", "scroll", "refresh"], l.rewind) }(), "pause" !== t && p()) }, destroy: l.cancel, play: p, pause: E, isPaused: a } } function Cover(t, e, n) { const { on: i } = EventInterface(t); function s(t) { e.Slides.forEach((e => { const n = child(e.container || e.slide, "img"); n && n.src && o(t, n, e) })) } function o(t, e, n) { n.style("background", t ? `center/cover no-repeat url("${e.src}")` : "", !0), display(e, t ? "none" : "") } return { mount: function () { n.cover && (i("lazyload:loaded", ((t, e) => { o(!0, t, e) })), i(["mounted", "updated", "refresh"], s.bind(null, !0))) }, destroy: function () { s(!1) } } } const BOUNCE_DIFF_THRESHOLD = 10, BOUNCE_DURATION = 600, FRICTION_FACTOR = .6, BASE_VELOCITY = 1.5, MIN_DURATION = 800; function Scroll(t, e, n) { const { on: i, emit: s } = EventInterface(t), { Move: o } = e, { getPosition: r, getLimit: l, exceededLimit: a } = o; let c, u; function d(e, i, E, S) { const h = r(); let A = 1; var _; i = i || (_ = abs(e - h), max(_ / 1.5, 800)), u = E, p(), c = RequestInterval(i, f, (i => { const s = r(), c = (h + (e - h) * function (t) { const { easingFunc: e } = n; return e ? e(t) : 1 - Math.pow(1 - t, 4) }(i) - r()) * A; var u; o.translate(s + c), t.is(SLIDE) && !S && a() && (A *= .6, abs(c) < 10 && (u = a(!1), d(l(!u), 600, null, !0))) }), 1), s("scroll"), c.start() } function f() { const e = r(), n = o.toIndex(e); between(n, 0, t.length - 1) || o.translate(o.shift(e, n > 0), !0), u && u(), s("scrolled") } function p() { c && c.cancel() } function E() { c && !c.isPaused() && (p(), f()) } return { mount: function () { i("move", p), i(["updated", "refresh"], E) }, destroy: p, scroll: d, cancel: E } } const FRICTION = 5, LOG_INTERVAL = 200, POINTER_DOWN_EVENTS = "touchstart mousedown", POINTER_MOVE_EVENTS = "touchmove mousemove", POINTER_UP_EVENTS = "touchend touchcancel mouseup"; function Drag(t, e, n) { const { on: i, emit: s, bind: o, unbind: r } = EventInterface(t), { Move: l, Scroll: a, Controller: c } = e, { track: u } = e.Elements, { resolve: d, orient: f } = e.Direction, { getPosition: p, exceededLimit: E } = l, S = { passive: !1, capture: !0 }; let h, A, _, g, T, m, L, C, R, y = !1; function I() { const { drag: t } = n; $(!t), T = "free" === t } function O(t) { if (!C) { const e = w(t); !e && t.button || (l.isBusy() ? prevent(t, !0) : (R = e ? u : window, _ = null, g = null, L = !1, o(R, POINTER_MOVE_EVENTS, N, S), o(R, POINTER_UP_EVENTS, v, S), l.cancel(), a.cancel(), b(t))) } } function N(e) { if (g || s("drag"), g = e, e.cancelable) if (m) { const n = V(e) - V(A) > 200, i = y !== (y = E()); (n || i) && b(e), l.translate(h + (P(e) - P(A)) / (y && t.is(SLIDE) ? 5 : 1)), s("dragging"), L = !0, prevent(e) } else { const t = abs(P(e) - P(A)); let { dragMinThreshold: i } = n; i = isObject(i) ? i : { mouse: 0, touch: +i || 10 }, m = t > (w(e) ? i.touch : i.mouse), D() && prevent(e) } } function v(i) { if (r(R, POINTER_MOVE_EVENTS, N), r(R, POINTER_UP_EVENTS, v), g) { if (m || i.cancelable && D()) { const s = function (e) { if (t.is(LOOP) || !y) { const t = A === g && _ || A, n = P(g) - P(t), i = V(e) - V(t), s = V(e) - V(g) < 200; if (i && s) return n / i } return 0 }(i), o = function (t) { return p() + sign(t) * min(abs(t) * (n.flickPower || 600), T ? 1 / 0 : e.Layout.listSize() * (n.flickMaxPages || 1)) }(s); T ? c.scroll(o) : t.is(FADE) ? c.go(t.index + f(sign(s))) : c.go(c.toDest(o), !0), prevent(i) } s("dragged") } m = !1 } function b(t) { _ = A, A = t, h = p() } function x(t) { !C && L && prevent(t, !0) } function D() { return abs(P(g) - P(A)) > abs(P(g, !0) - P(A, !0)) } function P(t, e) { return (w(t) ? t.touches[0] : t)[`page${d(e ? "Y" : "X")}`] } function V(t) { return t.timeStamp } function w(t) { return "undefined" != typeof TouchEvent && t instanceof TouchEvent } function $(t) { C = t } return { mount: function () { o(u, POINTER_MOVE_EVENTS, noop, S), o(u, POINTER_UP_EVENTS, noop, S), o(u, POINTER_DOWN_EVENTS, O, S), o(u, "click", x, { capture: !0 }), o(u, "dragstart", prevent), i(["mounted", "updated"], I) }, disable: $, isDragging: function () { return m } } } const IE_ARROW_KEYS = ["Left", "Right", "Up", "Down"]; function Keyboard(t, e, n) { const { on: i, bind: s, unbind: o } = EventInterface(t), { root: r } = e.Elements, { resolve: l } = e.Direction; let a; function c() { const { keyboard: t = "global" } = n; t && ("focused" === t ? (a = r, setAttribute(r, TAB_INDEX, 0)) : a = window, s(a, "keydown", d)) } function u() { o(a, "keydown"), isHTMLElement(a) && removeAttribute(a, TAB_INDEX) } function d(e) { const { key: n } = e, i = includes(IE_ARROW_KEYS, n) ? `Arrow${n}` : n; i === l("ArrowLeft") ? t.go("<") : i === l("ArrowRight") && t.go(">") } return { mount: function () { c(), i("updated", (() => { u(), c() })) }, destroy: u } } const SRC_DATA_ATTRIBUTE = "data-splide-lazy", SRCSET_DATA_ATTRIBUTE = "data-splide-lazy-srcset", IMAGE_SELECTOR = "[data-splide-lazy], [data-splide-lazy-srcset]"; function LazyLoad(t, e, n) { const { on: i, off: s, bind: o, emit: r } = EventInterface(t), l = "sequential" === n.lazyLoad; let a = [], c = 0; function u() { c = 0, a = [] } function d() { a = a.filter((e => !e._Slide.isWithin(t.index, n.perPage * ((n.preloadPages || 1) + 1)) || f(e))), a.length || s("moved") } function f(t) { const { _img: e } = t; addClass(t._Slide.slide, "is-loading"), o(e, "load error", (e => { !function (t, e) { const { _Slide: n } = t; removeClass(n.slide, "is-loading"), e || (remove(t._spinner), display(t._img, ""), r("lazyload:loaded", t._img, n), r("resize")); l && p() }(t, "error" === e.type) })), ["src", "srcset"].forEach((n => { t[n] && (setAttribute(e, n, t[n]), removeAttribute(e, "src" === n ? "data-splide-lazy" : SRCSET_DATA_ATTRIBUTE)) })) } function p() { c < a.length && f(a[c++]) } return { mount: function () { n.lazyLoad && (i(["mounted", "refresh"], (() => { u(), e.Slides.forEach((t => { queryAll(t.slide, IMAGE_SELECTOR).forEach((e => { const i = getAttribute(e, "data-splide-lazy"), s = getAttribute(e, SRCSET_DATA_ATTRIBUTE); if (i !== e.src || s !== e.srcset) { const o = create("span", n.classes.spinner, e.parentElement); setAttribute(o, ROLE, "presentation"), a.push({ _img: e, _Slide: t, src: i, srcset: s, _spinner: o }), display(e, "none") } })) })), l && p() })), l || i(["mounted", "refresh", "moved"], d)) }, destroy: u } } function Pagination(t, e, n) { const { on: i, emit: s, bind: o, unbind: r } = EventInterface(t), { Slides: l, Elements: a, Controller: c } = e, { hasFocus: u, getIndex: d } = c, f = []; let p; function E() { S(), n.pagination && l.isEnough() && (!function () { const { length: e } = t, { classes: i, i18n: s, perPage: r } = n, c = "slider" === n.pagination && a.slider || a.root, d = u() ? e : ceil(e / r); p = create("ul", i.pagination, c); for (let t = 0; t < d; t++) { const e = create("li", null, p), n = create("button", { class: i.page, type: "button" }, e), a = l.getIn(t).map((t => t.slide.id)), c = !u() && r > 1 ? s.pageX : s.slideX; o(n, "click", h.bind(null, t)), setAttribute(n, ARIA_CONTROLS, a.join(" ")), setAttribute(n, ARIA_LABEL, format(c, t + 1)), f.push({ li: e, button: n, page: t }) } }(), s("pagination:mounted", { list: p, items: f }, A(t.index)), _()) } function S() { p && (remove(p), f.forEach((t => { r(t.button, "click") })), empty(f), p = null) } function h(t) { c.go(`>${t}`, !0, (() => { const e = l.getAt(c.toIndex(t)); e && focus(e.slide) })) } function A(t) { return f[c.toPage(t)] } function _() { const t = A(d(!0)), e = A(d()); t && (removeClass(t.button, CLASS_ACTIVE), removeAttribute(t.button, ARIA_CURRENT)), e && (addClass(e.button, CLASS_ACTIVE), setAttribute(e.button, ARIA_CURRENT, !0)), s("pagination:updated", { list: p, items: f }, t, e) } return { items: f, mount: function () { E(), i(["updated", "refresh"], E), i(["move", "scrolled"], _) }, destroy: S, getAt: A } } const TRIGGER_KEYS = [" ", "Enter", "Spacebar"]; function Sync(t, e, n) { const { splides: i } = t, { list: s } = e.Elements; function o() { setAttribute(s, ARIA_ORIENTATION, n.direction !== TTB ? "horizontal" : null) } function r(e) { t.go(e.index) } function l(t, e) { includes(TRIGGER_KEYS, e.key) && (r(t), prevent(e)) } return { mount: function () { n.isNavigation ? function () { const { on: e, emit: n } = EventInterface(t); e("click", r), e("slide:keydown", l), e(["mounted", "updated"], o), setAttribute(s, ROLE, "menu"), n("navigation:mounted", t.splides) }() : function () { const e = []; i.concat(t).forEach(((t, n, i) => { EventInterface(t).on("move", ((n, s, o) => { i.forEach((i => { i === t || includes(e, t) || (e.push(i), i.go(i.is(LOOP) ? o : n)) })), empty(e) })) })) }() }, destroy: function () { removeAttribute(s, ALL_ATTRIBUTES) } } } function Wheel(t, e, n) { const { bind: i } = EventInterface(t); function s(e) { const { deltaY: n } = e; n && (t.go(n < 0 ? "<" : ">"), prevent(e)) } return { mount: function () { n.wheel && i(e.Elements.track, "wheel", s, { passive: !1, capture: !0 }) } } } var ComponentConstructors = Object.freeze({ __proto__: null, Options: Options, Direction: Direction, Elements: Elements, Slides: Slides, Layout: Layout, Clones: Clones, Move: Move, Controller: Controller, Arrows: Arrows, Autoplay: Autoplay, Cover: Cover, Scroll: Scroll, Drag: Drag, Keyboard: Keyboard, LazyLoad: LazyLoad, Pagination: Pagination, Sync: Sync, Wheel: Wheel }); const I18N = { prev: "Previous slide", next: "Next slide", first: "Go to first slide", last: "Go to last slide", slideX: "Go to slide %s", pageX: "Go to page %s", play: "Start autoplay", pause: "Pause autoplay" }, DEFAULTS = { type: "slide", speed: 400, waitForTransition: !0, perPage: 1, arrows: !0, pagination: !0, interval: 5e3, pauseOnHover: !0, pauseOnFocus: !0, resetProgress: !0, easing: "cubic-bezier(0.25, 1, 0.5, 1)", drag: !0, direction: "ltr", slideFocus: !0, trimSpace: !0, focusableNodes: "a, button, textarea, input, select, iframe", classes: CLASSES, i18n: I18N }; function Fade(t, e, n) { const { on: i } = EventInterface(t); return { mount: function () { i(["mounted", "refresh"], (() => { nextTick((() => { e.Slides.style("transition", `opacity ${n.speed}ms ${n.easing}`) })) })) }, start: function (t, n) { const { track: i } = e.Elements; style(i, "height", unit(rect(i).height)), nextTick((() => { n(), style(i, "height", "") })) }, cancel: noop } } function Slide(t, e, n) { const { bind: i } = EventInterface(t), { Move: s, Controller: o } = e, { list: r } = e.Elements; let l; function a() { c("") } function c(t) { style(r, "transition", t) } return { mount: function () { i(r, "transitionend", (t => { t.target === r && l && (a(), l()) })) }, start: function (e, i) { const r = s.toPosition(e, !0), a = s.getPosition(), u = function (e) { const { rewindSpeed: i } = n; if (t.is(SLIDE) && i) { const t = o.getIndex(!0), n = o.getEnd(); if (0 === t && e >= n || t >= n && 0 === e) return i } return n.speed }(e); abs(r - a) >= 1 && u >= 1 ? (c(`transform ${u}ms ${n.easing}`), s.translate(r, !0), l = i) : (s.jump(e), i()) }, cancel: a } } const _Splide = class { constructor(t, e) { this.event = EventBus(), this.Components = {}, this.state = State(1), this.splides = [], this._options = {}, this._Extensions = {}; const n = isString(t) ? query(document, t) : t; assert(n, `${n} is invalid.`), this.root = n, merge(DEFAULTS, _Splide.defaults), merge(merge(this._options, DEFAULTS), e || {}) } mount(t, e) { const { state: n, Components: i } = this; assert(n.is([1, 5]), "Already mounted!"), n.set(1), this._Components = i, this._Transition = e || this._Transition || (this.is(FADE) ? Fade : Slide), this._Extensions = t || this._Extensions; return forOwn(assign({}, ComponentConstructors, this._Extensions, { Transition: this._Transition }), ((t, e) => { const n = t(this, i, this._options); i[e] = n, n.setup && n.setup() })), forOwn(i, (t => { t.mount && t.mount() })), this.emit("mounted"), addClass(this.root, "is-initialized"), n.set(3), this.emit("ready"), this } sync(t) { return this.splides.push(t), t.splides.push(this), this } go(t) { return this._Components.Controller.go(t), this } on(t, e) { return this.event.on(t, e, null, 20), this } off(t) { return this.event.off(t), this } emit(t) { return this.event.emit(t, ...slice(arguments, 1)), this } add(t, e) { return this._Components.Slides.add(t, e), this } remove(t) { return this._Components.Slides.remove(t), this } is(t) { return this._options.type === t } refresh() { return this.emit("refresh"), this } destroy(t = !0) { const { event: e, state: n } = this; return n.is(1) ? e.on("ready", this.destroy.bind(this, t), this) : (forOwn(this._Components, (e => { e.destroy && e.destroy(t) }), !0), e.emit("destroy"), e.destroy(), t && empty(this.splides), n.set(5)), this } get options() { return this._options } set options(t) { const { _options: e } = this; merge(e, t), this.state.is(1) || this.emit("updated", e) } get length() { return this._Components.Slides.getLength(!0) } get index() { return this._Components.Controller.getIndex() } }; let Splide = _Splide; Splide.defaults = {}, Splide.STATES = STATES; const CLASS_RENDERED = "is-rendered", RENDERER_DEFAULT_CONFIG = { listTag: "ul", slideTag: "li" }; class Style { constructor(t, e) { this.styles = {}, this.id = t, this.options = e } rule(t, e, n, i) { i = i || "default"; const s = this.styles[i] = this.styles[i] || {}; (s[t] = s[t] || {})[e] = n } build() { let t = ""; return this.styles.default && (t += this.buildSelectors(this.styles.default)), Object.keys(this.styles).sort(((t, e) => "min" === this.options.mediaQuery ? +t - +e : +e - +t)).forEach((e => { "default" !== e && (t += `@media screen and (max-width: ${e}px) {`, t += this.buildSelectors(this.styles[e]), t += "}") })), t } buildSelectors(t) { let e = ""; return forOwn(t, ((t, n) => { e += `#${this.id} ${n} {`, forOwn(t, ((t, n) => { (t || 0 === t) && (e += `${n}: ${t};`) })), e += "}" })), e } } class SplideRenderer { constructor(t, e, n, i) { this.slides = [], this.options = {}, this.breakpoints = [], merge(DEFAULTS, i || {}), merge(merge(this.options, DEFAULTS), e || {}), this.contents = t, this.config = assign({}, RENDERER_DEFAULT_CONFIG, n || {}), this.id = this.config.id || uniqueId("splide"), this.Style = new Style(this.id, this.options), this.Direction = Direction(null, null, this.options), assert(this.contents.length, "Provide at least 1 content."), this.init() } static clean(t) { const { on: e } = EventInterface(t), { root: n } = t, i = queryAll(n, `.${CLASS_CLONE}`); e("mounted", (() => { remove(child(n, "style")) })), remove(i) } init() { this.parseBreakpoints(), this.initSlides(), this.registerRootStyles(), this.registerTrackStyles(), this.registerSlideStyles(), this.registerListStyles() } initSlides() { push(this.slides, this.contents.map(((t, e) => { (t = isString(t) ? { html: t } : t).styles = t.styles || {}, t.attrs = t.attrs || {}, this.cover(t); const n = `${this.options.classes.slide} ${0 === e ? CLASS_ACTIVE : ""}`; return assign(t.attrs, { class: `${n} ${t.attrs.class || ""}`.trim(), style: this.buildStyles(t.styles) }), t }))), this.isLoop() && this.generateClones(this.slides) } registerRootStyles() { this.breakpoints.forEach((([t, e]) => { this.Style.rule(" ", "max-width", unit(e.width), t) })) } registerTrackStyles() { const { Style: t } = this, e = ".splide__track"; this.breakpoints.forEach((([n, i]) => { t.rule(e, this.resolve("paddingLeft"), this.cssPadding(i, !1), n), t.rule(e, this.resolve("paddingRight"), this.cssPadding(i, !0), n), t.rule(e, "height", this.cssTrackHeight(i), n) })) } registerListStyles() { const { Style: t } = this; this.breakpoints.forEach((([e, n]) => { t.rule(".splide__list", "transform", this.buildTranslate(n), e) })) } registerSlideStyles() { const { Style: t } = this, e = ".splide__slide"; this.breakpoints.forEach((([n, i]) => { t.rule(e, "width", this.cssSlideWidth(i), n), t.rule(e, this.resolve("marginRight"), unit(i.gap) || "0px", n); const s = this.cssSlideHeight(i); s ? t.rule(e, "height", s, n) : t.rule(e, "padding-top", this.cssSlidePadding(i), n), t.rule(`${e} > img`, "display", i.cover ? "none" : "inline", n) })) } buildTranslate(t) { const { resolve: e, orient: n } = this.Direction, i = []; return i.push(this.cssOffsetClones(t)), i.push(this.cssOffsetGaps(t)), this.isCenter(t) && (i.push(this.buildCssValue(n(-50), "%")), i.push(...this.cssOffsetCenter(t))), i.filter(Boolean).map((t => `translate${e("X")}(${t})`)).join(" ") } cssOffsetClones(t) { const { resolve: e, orient: n } = this.Direction, i = this.getCloneCount(); if (this.isFixedWidth(t)) { const { value: s, unit: o } = this.parseCssValue(t[e("fixedWidth")]); return this.buildCssValue(n(s) * i, o) } return `${n(100 * i / t.perPage)}%` } cssOffsetCenter(t) { const { resolve: e, orient: n } = this.Direction; if (this.isFixedWidth(t)) { const { value: i, unit: s } = this.parseCssValue(t[e("fixedWidth")]); return [this.buildCssValue(n(i / 2), s)] } const i = [], { perPage: s, gap: o } = t; if (i.push(`${n(50 / s)}%`), o) { const { value: t, unit: e } = this.parseCssValue(o), r = (t / s - t) / 2; i.push(this.buildCssValue(n(r), e)) } return i } cssOffsetGaps(t) { const e = this.getCloneCount(); if (e && t.gap) { const { orient: n } = this.Direction, { value: i, unit: s } = this.parseCssValue(t.gap); if (this.isFixedWidth(t)) return this.buildCssValue(n(i * e), s); const { perPage: o } = t, r = e / o; return this.buildCssValue(n(r * i), s) } return "" } resolve(t) { return camelToKebab(this.Direction.resolve(t)) } cssPadding(t, e) { const { padding: n } = t, i = this.Direction.resolve(e ? "right" : "left", !0); return n && unit(n[i] || (isObject(n) ? 0 : n)) || "0px" } cssTrackHeight(t) { let e = ""; return this.isVertical() && (e = this.cssHeight(t), assert(e, '"height" is missing.'), e = `calc(${e} - ${this.cssPadding(t, !1)} - ${this.cssPadding(t, !0)})`), e } cssHeight(t) { return unit(t.height) } cssSlideWidth(t) { return t.autoWidth ? "" : unit(t.fixedWidth) || (this.isVertical() ? "" : this.cssSlideSize(t)) } cssSlideHeight(t) { return unit(t.fixedHeight) || (this.isVertical() ? t.autoHeight ? "" : this.cssSlideSize(t) : this.cssHeight(t)) } cssSlideSize(t) { const e = unit(t.gap); return `calc((100%${e && ` + ${e}`})/${t.perPage || 1}${e && ` - ${e}`})` } cssSlidePadding(t) { const { heightRatio: e } = t; return e ? 100 * e + "%" : "" } buildCssValue(t, e) { return `${t}${e}` } parseCssValue(t) { if (isString(t)) { return { value: parseFloat(t) || 0, unit: t.replace(/\d*(\.\d*)?/, "") || "px" } } return { value: t, unit: "px" } } parseBreakpoints() { const { breakpoints: t } = this.options; this.breakpoints.push(["default", this.options]), t && forOwn(t, ((t, e) => { this.breakpoints.push([e, merge(merge({}, this.options), t)]) })) } isFixedWidth(t) { return !!t[this.Direction.resolve("fixedWidth")] } isLoop() { return this.options.type === LOOP } isCenter(t) { if ("center" === t.focus) { if (this.isLoop()) return !0; if (this.options.type === SLIDE) return !this.options.trimSpace } return !1 } isVertical() { return this.options.direction === TTB } buildClasses() { const { options: t } = this; return [CLASS_ROOT, `${CLASS_ROOT}--${t.type}`, `${CLASS_ROOT}--${t.direction}`, t.drag && `${CLASS_ROOT}--draggable`, t.isNavigation && `${CLASS_ROOT}--nav`, CLASS_ACTIVE, !this.config.hidden && "is-rendered"].filter(Boolean).join(" ") } buildAttrs(t) { let e = ""; return forOwn(t, ((t, n) => { e += t ? ` ${camelToKebab(n)}="${t}"` : "" })), e.trim() } buildStyles(t) { let e = ""; return forOwn(t, ((t, n) => { e += ` ${camelToKebab(n)}:${t};` })), e.trim() } renderSlides() { const { slideTag: t } = this.config; return this.slides.map((e => `<${t} ${this.buildAttrs(e.attrs)}>${e.html || ""}</${t}>`)).join("") } cover(t) { const { styles: e, html: n = "" } = t; if (this.options.cover && !this.options.lazyLoad) { const t = n.match(/<img.*?src\s*=\s*(['"])(.+?)\1.*?>/); t && t[2] && (e.background = `center/cover no-repeat url('${t[2]}')`) } } generateClones(t) { const { classes: e } = this.options, n = this.getCloneCount(), i = t.slice(); for (; i.length < n;)push(i, i); push(i.slice(-n).reverse(), i.slice(0, n)).forEach(((i, s) => { const o = assign({}, i.attrs, { class: `${i.attrs.class} ${e.clone}` }), r = assign({}, i, { attrs: o }); s < n ? t.unshift(r) : t.push(r) })) } getCloneCount() { if (this.isLoop()) { const { options: t } = this; if (t.clones) return t.clones; return max(...this.breakpoints.map((([, t]) => t.perPage))) * ((t.flickMaxPages || 1) + 1) } return 0 } renderArrows() { let t = ""; return t += `<div class="${this.options.classes.arrows}">`, t += this.renderArrow(!0), t += this.renderArrow(!1), t += "</div>", t } renderArrow(t) { const { classes: e, i18n: n } = this.options, i = { class: `${e.arrow} ${t ? e.prev : e.next}`, type: "button", ariaLabel: t ? n.prev : n.next }; return `<button ${this.buildAttrs(i)}><svg xmlns="${XML_NAME_SPACE}" viewBox="0 0 40 40" width="40" height="40"><path d="${this.options.arrowPath || PATH}" /></svg></button>` } html() { const { rootClass: t, listTag: e, arrows: n, beforeTrack: i, afterTrack: s, slider: o, beforeSlider: r, afterSlider: l } = this.config; let a = ""; return a += `<div id="${this.id}" class="${this.buildClasses()} ${t || ""}">`, a += `<style>${this.Style.build()}</style>`, o && (a += r || "", a += '<div class="splide__slider">'), a += i || "", n && (a += this.renderArrows()), a += '<div class="splide__track">', a += `<${e} class="splide__list">`, a += this.renderSlides(), a += `</${e}>`, a += "</div>", a += s || "", o && (a += "</div>", a += l || ""), a += "</div>", a } } exports.CLASSES = CLASSES, exports.CLASS_ACTIVE = CLASS_ACTIVE, exports.CLASS_ARROW = CLASS_ARROW, exports.CLASS_ARROWS = CLASS_ARROWS, exports.CLASS_ARROW_NEXT = CLASS_ARROW_NEXT, exports.CLASS_ARROW_PREV = CLASS_ARROW_PREV, exports.CLASS_AUTOPLAY = CLASS_AUTOPLAY, exports.CLASS_CLONE = CLASS_CLONE, exports.CLASS_CONTAINER = CLASS_CONTAINER, exports.CLASS_INITIALIZED = "is-initialized", exports.CLASS_LIST = CLASS_LIST, exports.CLASS_LOADING = "is-loading", exports.CLASS_NEXT = "is-next", exports.CLASS_PAGINATION = CLASS_PAGINATION, exports.CLASS_PAGINATION_PAGE = CLASS_PAGINATION_PAGE, exports.CLASS_PAUSE = CLASS_PAUSE, exports.CLASS_PLAY = CLASS_PLAY, exports.CLASS_PREV = "is-prev", exports.CLASS_PROGRESS = CLASS_PROGRESS, exports.CLASS_PROGRESS_BAR = CLASS_PROGRESS_BAR, exports.CLASS_ROOT = CLASS_ROOT, exports.CLASS_SLIDE = CLASS_SLIDE, exports.CLASS_SLIDER = CLASS_SLIDER, exports.CLASS_SPINNER = CLASS_SPINNER, exports.CLASS_TRACK = CLASS_TRACK, exports.CLASS_VISIBLE = "is-visible", exports.EVENT_ACTIVE = "active", exports.EVENT_ARROWS_MOUNTED = "arrows:mounted", exports.EVENT_ARROWS_UPDATED = "arrows:updated", exports.EVENT_AUTOPLAY_PAUSE = "autoplay:pause", exports.EVENT_AUTOPLAY_PLAY = "autoplay:play", exports.EVENT_AUTOPLAY_PLAYING = "autoplay:playing", exports.EVENT_CLICK = "click", exports.EVENT_DESTROY = "destroy", exports.EVENT_DRAG = "drag", exports.EVENT_DRAGGED = "dragged", exports.EVENT_DRAGGING = "dragging", exports.EVENT_HIDDEN = "hidden", exports.EVENT_INACTIVE = "inactive", exports.EVENT_LAZYLOAD_LOADED = "lazyload:loaded", exports.EVENT_MOUNTED = "mounted", exports.EVENT_MOVE = "move", exports.EVENT_MOVED = "moved", exports.EVENT_NAVIGATION_MOUNTED = "navigation:mounted", exports.EVENT_PAGINATION_MOUNTED = "pagination:mounted", exports.EVENT_PAGINATION_UPDATED = "pagination:updated", exports.EVENT_READY = "ready", exports.EVENT_REFRESH = "refresh", exports.EVENT_REPOSITIONED = "repositioned", exports.EVENT_RESIZE = "resize", exports.EVENT_RESIZED = "resized", exports.EVENT_SCROLL = "scroll", exports.EVENT_SCROLLED = "scrolled", exports.EVENT_SLIDE_KEYDOWN = "slide:keydown", exports.EVENT_UPDATED = "updated", exports.EVENT_VISIBLE = "visible", exports.EventBus = EventBus, exports.EventInterface = EventInterface, exports.RequestInterval = RequestInterval, exports.STATUS_CLASSES = STATUS_CLASSES, exports.Splide = Splide, exports.SplideRenderer = SplideRenderer, exports.State = State, exports.Throttle = Throttle, exports.default = Splide;
//# sourceMappingURL=/sm/109e7bd4a89c5b542bce1157b13ad606d4cd9188a481cdb2d5e6f3b0155dc419.map
